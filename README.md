# netty 的一些简单的demo
## netty discard server
只接受连接，不响应用户输入的服务
## netty echo server
接受连接，并返回客戶端输入
## netty chart server
聊天服务，多個客戶端，通过@其他用戶進行聊天沟通

# netty 源碼解讀
## 异步非阻塞通信
java1.4之前，进行网络应用开发，使用的BIO模型进行通信，读写网络书记，往往每个连接建立，都要创建一个对应的线程，“守”在连接的读写接口，为上层业务提供数据的发送和接受；随着连接数的增多，线程数量线性增长，消耗大量的系统资源。<br/>
在jvm内存模型中，堆内存是共享内存，而每个线程的栈空间，却是与线程同生命周期的。如果线程的栈空间大小是200k，那么，5000个线程会消耗1g的内存作为栈空间使用。在BIO模型网络应用中，大部分情况下，线程都是“守”在读写接口上，这就造成，线程占用了大量的栈空间，却等在那里，没有给CPU“喂”指令，CPU的利用率降低，同时栈空间也白白占用，留给运行线程的内存资源相应减少；<br/>
另外，每个连接一个线程，连接数量增加，线程数量对应增加。线程被阻塞和被读信号唤醒的时候，会导致上下文切换，系统层面要进行额外的大量工作，将正在运行的现场保存，并调出唤醒的线程，从而保证被唤醒程序的正常运行。这个过程存在的系统开销，是大量异步线程创建之后的另一个副作用。CPU用于执行这些系统开销的时间增多，自然用于处理用户业务的时间减少；吞吐量降低。<br/>
java1.4之后，引入NIO的概念，NIO就是非阻塞IO，这种新的模型，将多个channel和一个selector绑定起来，通过对这个selector进行读写事件监听，就可以完成绑定其上的所有channel的读写操作。而不用每个连接对应一个线程操作。在原生的java nio中，1024个连接，才启动一个线程处理读写事件。从java栈的角度看，内存利用率提高了千倍。而线程数量的减少，更是将上下文切换占用的CPU时间大大降低，从而提升了CPU利用率。<br/>
netty正是在NIO基础上，诞生的网络应用开发框架。在原生nio基础上，进行了良好的封装，提供简洁易用的编成接口。在提供高效的网络读写能力的同时，也提供了高效的开发体验。良好的分层设计，使得基于Netty进行设计开发的网络应用，在扩展性上表现良好。
![](https://netty.io/images/components.png)，
## 零拷贝
Netty的接收和发送ByteBuffer采用DIRECT BUFFERS，使用堆外直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝。Netty提供了组合Buffer对象，可以聚合多个ByteBuffer对象，用户可以像操作一个Buffer那样方便的对组合Buffer进行操作，避免了传统通过内存拷贝的方式将几个小Buffer合并成一个大的Buffer。这天然支持在进行应用开发，业务数据编解码的时候的分层设计思想。
## 无锁化的串行设计理念
在大多数场景下，并行多线程处理可以提升系统的并发性能。但是，如果对于共享资源的并发访问处理不当，会带来严重的锁竞争，这最终会导致性能的下降。为了尽可能的避免锁竞争带来的性能损耗，可以通过串行化设计，即消息的处理尽可能在同一个线程内完成，期间不进行线程切换，这样就避免了多线程竞争和同步锁。
为了尽可能提升性能，Netty采用了串行无锁化设计，在IO线程内部进行串行操作，避免多线程竞争导致的性能下降。表面上看，串行化设计似乎 CPU利用率不高，并发程度不够。但是，通过调整NIO线程池的线程参数，可以同时启动多个串行化的线程并行运行，这种局部无锁化的串行线程设计相比一个 队列-多个工作线程模型性能更优。
Netty的NioEventLoop读取到消息之后，直接调用ChannelPipeline的fireChannelRead(Object msg)，只要用户不主动切换线程，一直会由NioEventLoop调用到用户的Handler，期间不进行线程切换，这种串行化处理方式避免了多线程 操作导致的锁的竞争，从性能角度看是最优的。
## 高效的并发编程
Netty的高效并发编程主要体现在如下几点：
1) volatile的大量、正确使用;
2) CAS和原子类的广泛使用；
3) 线程安全容器的使用；
4) 通过读写锁提升并发性能。
## 高性能的序列化框架
影响序列化性能的关键因素总结如下：
1) 序列化后的码流大小（网络带宽的占用）；
2) 序列化&反序列化的性能（CPU资源占用）；
3) 是否支持跨语言（异构系统的对接和开发语言切换）。
Netty默认提供了对Google Protobuf的支持，通过扩展Netty的编解码接口，用户可以实现其它的高性能序列化框架，例如Thrift的压缩二进制编解码框架。
## 灵活的TCP参数配置能力
合理设置TCP参数在某些场景下对于性能的提升可以起到显著的效果，例如SO_RCVBUF和SO_SNDBUF。如果设置不当，对性能的影响是非常大的。下面总结下对性能影响比较大的几个配置项：
1) SO_RCVBUF和SO_SNDBUF：通常建议值为128K或者256K；
2) SO_TCPNODELAY：NAGLE算法通过将缓冲区内的小封包自动相连，组成较大的封包，阻止大量小封包的发送阻塞网络，从而提高网络应用效率。但是对于时延敏感的应用场景需要关闭该优化算法；
3) 软中断：如果Linux内核版本支持RPS（2.6.35以上版本），开启RPS后可以实现软中断，提升网络吞吐量。RPS根据数据包的源地址，目的地址以及目的和源端口，计算出一个hash值，然后根据这个hash值来选择软中断运行的cpu，从上层来看，也就是说将每个连接和cpu绑定，并通过这个 hash值，来均衡软中断在多个cpu上，提升网络并行处理性能。
Netty在启动辅助类中可以灵活的配置TCP参数，满足不同的用户场景。
## auto_read/readable/writeable限流

## 參考文章
https://netty.io/wiki/user-guide-for-4.x.html<br/>
https://blog.csdn.net/zero__007/article/details/51326591<br/>
https://www.cnblogs.com/doit8791/p/7461479.html<br/>
